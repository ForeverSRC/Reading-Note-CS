# 第6章 对象和数据结构

## 6.1 数据抽象

隐藏实现并非只是在变量之间放一个函数层那么简单。隐藏实现关乎抽象。

类并不简单地用getter和setter将变量推向外部，而是暴露接口，以便用户无需了解数据的实现就能操作数据本体。

> 傻乐着乱加getter和setter，是最坏的选择。

---

然而，某些工具类利用反射对其他类的实例进行赋值时，往往是通过setter进行，因此有时候也需要“傻乐着乱加”。当然，对这种情况应该有所把握，尽量做到不“傻乐着乱加”。

## 6.2 数据、对象的反对称性

**对象和数据结构**

* 对象把数据隐藏于抽象之后，暴露操作数据的函数
  * 定义接口或抽象类进行抽象
* 数据结构暴露其数据，没有提供有意义的函数

**过程式代码与面向对象代码**

* 过程式代码（使用数据结构的代码）便于在不改动**既有数据结构**的前提下添加新函数
* 面向对象代码便于在不改动**既有函数**的前提下添加新类

反过来讲：

> 过程式代码难以添加新数据结构，因为必须修改所有函数。面向对象代码难以添加新函数，因为必须修改所有类

根据不同的情况进行处理。

## 6.3 得墨忒耳律

> 得墨忒耳律：模块不应了解它操作对象的内部情形

得墨忒耳律认为，类C的方法f只应该调用以下对象的方法：

* C
* 由f创建的对象
* 作为参数传递给f的对象
* 由C的实体变量持有的对象

方法不应调用由任何函数返回的对象的方法（例如：链式调用）

### 6.3.1 火车失事

一连串的链式调用，每次返回的都是对象内部的私有属性的话，即违反了得墨忒尔律。

如果是数据结构的链式访问属性，则不违反得墨忒耳律。

### 6.3.2 混杂

### 6.3.3 隐藏结构

避免链式调用，可以让对象提供一个方法，达成链式调用相同的效果，但是这样会失去链式调用的灵活性。

## 6.4 数据传送对象

DTO：最为精炼的数据结构，只有公共变量，没有函数的类。

最常见的DTO是Bean结构的：私有成员，提供构造函数、getter和setter

## 6.5 小结

对象（指抽象类或接口）暴露行为，隐藏数据，便于添加新对象类型而无需修改既有行为，同时也难以在既有对象中添加新行为。

数据结构暴露数据，没有明显的行为，便于向既有数据结构添加新行为，同时也难以向既有函数添加新数据结构。