# 第13章 并发编程

## 13.1 为什么要并发

并发是一种解耦策略，将**做什么**和**何时做**分解开。

解耦目的与时机能明显地改进应用程序的吞吐量和结构。

并发的评价：

* 并发会在性能和编写额外代码上增加一些开销
* 正确的并发是复杂的，即使简单的问题也是如此
* 并发缺陷并非总能重现，所以常被看作偶发事件而忽略
* 并发常常需要对设计策略的根本性修改

## 13.2 挑战

## 13.3 并发防御原则

### 13.3.1 单一权责原则

建议：分离并发相关代码与其他代码

### 13.3.2 推论：限制数据作用域

建议：谨记数据封装，严格限制对可能被共享的数据的访问

### 13.3.3 推论：使用数据副本

* 复制对象，以只读方式对待
* 复制对象，从多个线程中收集所有副本的结果，并在单个线程中合并这些结果

### 13.3.4 推论：线程应尽可能地独立

让每个线程在自己的世界中存在，不与其他线程共享数据。

建议：尝试将数据分解到可被独立线程（可能在不同处理器上）操作的独立子集。

## 13.4 了解Java库

* 使用类库提供的线程安全群集
* 使用executor框架执行无关任务
* 尽可能使用非锁定解决方案
* 有几个类并不是线程安全的

建议：对于java，掌握：

* `java.util.concurrent`
* `java.util.concurrent.atomic`
* `java.util.concurrent.locks`

## 13.5 了解执行模型

基础定义：

| 定义     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| 限定资源 | 并发环境中有着固定尺寸或数量的资源。例如数据库连接和固定尺寸读/写缓存等 |
| 互斥     | 每一时刻仅有一个线程能访问共享数据或共享资源                 |
| 线程饥饿 | 一个或一组线程在很长时间内或永久被禁止                       |
| 死锁     | 两个或多个线程互相等待执行的结束，每个线程都拥有其他线程需要的资源，得不大其他线程拥有的资源，就无法终止 |
| 活锁     | 执行次序一致的线程，每个都想要起步，但发现其他线程已经“在路上”。线程会持续尝试起步，但在很长时间内无法如愿，甚至无法启动 |

### 13.5.1 生产者-消费者模型

生产者和消费者之间的队列是一种**限定资源**。

### 13.5.2 读者-写者模型

某个资源经常被读，偶尔被写。此时，吞吐量会是个问题：

* 增加吞吐量会导致线程饥饿和过时信息积累
  * 此场景下写线程总是不被执行
* 更新，会影响吞吐量
  * 写线程写的时候，所有读线程都阻塞
* 读者读旧信息，不去读写者正在更新的信息
  * 会读到旧的信息

挑战之处：

* 平衡读者线程和写者线程的需求
* 实现正确操作
* 提供合理的吞吐量
* 避免线程饥饿

### 13.5.3 哲学家就餐问题

问题：死锁、活锁、吞吐量、效率降低

---

建议：学习上述的基础算法，理解其解决方案

## 13.6 警惕同步方法之间的依赖

建议：避免使用一个共享对象的多个方法

有时必须使用一个共享对象的多个方法，此种情况下的3种写对代码的手段：

* 基于客户端的锁定
  * 客户端代码在调用第一个方法前，锁定服务端，确保锁的范围覆盖了调用最后一个方法的代码
* 基于服务端的锁定
  * 在服务端内创建锁定服务端的方法，调用所有方法，然后解锁，让客户端代码调用新方法
* 适配服务端
  * 创建执行锁定的中间层

## 13.7 保持同步区域微小

扩大临界区会增加资源争用，降低执行效率。

## 13.8 很难编写正确的关闭代码

建议：尽早考虑关闭问题，尽早令其正常工作。

*在go语言编程中，一定要考虑每个goroutine何时退出，避免发生goroutine泄露*

## 13.9 测试线程代码

编写有潜力暴露问题的测试，在不同的编程配置、系统配置和负载条件下频繁运行。

### 13.9.1 将伪失败看作可能的线程问题

建议：不要将系统错误归咎于偶发事件

### 13.9.2 先使非线程代码可工作

建议：不要同时追踪非线程缺陷和线程缺陷，确保代码在线程之外可工作。

### 13.9.3 编写可插拔的线程代码

编写可在数个配置环境下运行的线程代码：

* 单线程与多线程在执行时不同的情况
* 线程代码与实物或测试替身互动
* 用运行快速、缓慢和有变动的测试替身执行
* 将测试配置为能运行一定数量的迭代

### 13.9.4 编写可调整的线程代码

* 允许线程数量可调整
* 允许线程根据吞吐量和系统使用率自我调整

### 13.9.5 运行多于处理器数量的线程

任务交换越频繁，越有可能找到错过临界区或导致死锁的代码

### 13.9.6 在不同平台上运行

### 13.9.7 装置试错代码

### 13.9.8 硬编码

### 13.9.9 自动化
